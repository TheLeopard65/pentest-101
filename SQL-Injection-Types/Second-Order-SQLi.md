# Second-Order SQL Injection (SQLi) Guide

Second-Order SQL Injection occurs when user input is first stored by an application and then later used in a SQL query. The SQL injection does not manifest immediately but is triggered when the stored data is processed later. This type of SQLi can be more challenging to detect because the malicious input is not directly executed but only becomes a problem when re-used or re-processed.

## Steps to Perform Second-Order SQL Injection

### 1. **Identify Potential Input Points**
1. **Explore the Application**: Identify input fields where data is accepted and stored. Common targets include:
   - Registration forms
   - Comment sections
   - User profile updates
   - Any form of data storage or input that is later used in a SQL query

2. **Submit Test Inputs**: Enter different inputs to determine if they are stored and later used. Start with basic SQL injection payloads to test if the application is vulnerable:
     ```SQL
     ' OR '1'='1
     " OR "1"="1
     ```

### 2. **Confirm Storage of Input**
1. **Verify Data Storage**: Ensure that your input is stored in the application. Check if the application saves the input and re-displays it in some part of the application. For example:
   - After submitting a form, check if the input is displayed on a profile page or in a list.

2. **Review Stored Data**: Check if the input data is stored in a database. This can be done by:
   - Viewing stored data through application features (e.g., user profiles, comments)
   - Inspecting application behavior to confirm that input data persists.

### 3. **Identify Execution Points**
1. **Locate Execution of Stored Data**: Determine where and how the stored input is later used in SQL queries. This could include:
   - Search functions
   - Displaying user-generated content
   - Querying user data based on stored input

2. **Test Execution Points**: Inject payloads at execution points to see if the stored data triggers a SQL injection. Example payloads might include:
     ```SQL
     ' OR '1'='1' --
     ```

### 4. **Exploitation of Second-Order SQLi**

1. **Determine the Context**: Understand how the stored data is used in SQL queries. For example:
   - Does the application use the stored data in a search query or during user login?
   - Is the stored data used in administrative functions?

2. **Craft Malicious Input**: Inject payloads into input fields that will be stored and later executed. Examples include:
   - **Input for Registration or Profile**: 
     ```SQL
     '; DROP TABLE users; --
     ```
   - **Comment Section**:
     ```SQL
     ' UNION SELECT username, password FROM users -- 
     ```

3. **Trigger the Stored Payload**: Perform actions that would cause the stored data to be executed. For example:
   - Search for a stored input that includes SQL payloads
   - Access a page or function that processes stored input in a SQL query

4. **Extract Data or Modify Database**: Depending on the vulnerability, you may:
   - **Extract Data**: Use payloads to retrieve information from the database.
   - **Modify Database**: Inject commands to alter the database schema or data.

### 5. **Verify and Document Findings**

1. **Verify Vulnerability**: Confirm that the SQL injection payload works and that it accurately reflects the behavior of the stored data.
2. **Document Results**: Record details of your findings, including:
   - Injection points and payloads used
   - Data extracted or modified
   - Application behavior changes and impact
   - Capture screenshots or save request/response logs as evidence.

3. **Assess Impact**: Evaluate the impact of the SQLi vulnerability based on the data retrieved or modified. Consider the potential risks and consequences.

4. **Prepare Recommendations**: Provide recommendations for mitigating second-order SQLi vulnerabilities, such as:
   - Using parameterized queries or prepared statements to prevent SQL injection
   - Implementing robust input validation and sanitization
   - Limiting the privileges of database accounts
   - Regularly reviewing and updating security measures

## EXAMPLE SCENARIO: Testing a User Profile Update

1. **Identify Injection Point**: Suppose you have a user profile update form where you can input data such as `username` or `bio`.

2. **Submit Test Inputs**: Inject a SQL payload into the profile form and submit:
     ```SQL
     ' OR '1'='1' --
     ```

3. **Verify Storage**: Check if the input is stored by viewing the updated profile or checking the database.

4. **Locate Execution Points**: Identify where the stored input is used in SQL queries, such as a search function or another profile view.

5. **Trigger and Exploit Payload**: Perform actions that use the stored input in SQL queries:
   - Search for a user with the stored input
   - Access a page that displays or processes the stored input

6. **Extract Data**: If the stored data is executed in a SQL query, you might use payloads to retrieve information:
     ```SQL
     ' UNION SELECT username, password FROM users --
     ```

## Conclusion

Second-Order SQL Injection involves injecting malicious SQL into an input that is stored by the application and later executed in a different SQL query. By understanding where and how the input is stored and subsequently used, you can exploit this vulnerability to extract or modify data.

Always ensure you have explicit permission to perform penetration testing and adhere to ethical guidelines during your assessment.
